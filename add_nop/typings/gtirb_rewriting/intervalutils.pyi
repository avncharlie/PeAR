"""
This type stub file was generated by pyright.
"""

import dataclasses
import gtirb
from typing import Iterable, List, Mapping, MutableMapping, Optional
from .utils import OffsetMapping

class PaddingError(Exception):
    """Indicates an error inserting padding to reach a desired alignment."""
    ...


@dataclasses.dataclass
class BlockGroup:
    """A group of overlapping blocks."""
    begin: int
    end: int
    blocks: List[gtirb.ByteBlock]
    ...


def split_byte_interval(interval: gtirb.ByteInterval, alignment: Optional[MutableMapping[gtirb.Node, int]] = ..., tables: Optional[Iterable[OffsetMapping[object]]] = ...) -> List[gtirb.ByteInterval]:
    """Split a ByteInterval to put each block in its own interval.

    After the split, the original interval will hold the first block (ordered
    by offset). Each remaining block will be in a new new byte interval. Any
    bytes outside of a block will be included in the interval containing the
    preceding block; the first interval will contain the bytes before and after
    the first block.

    Because overlapping blocks share the bytes where they overlap, some
    intervals may contain more than one block after the split. These intervals
    will contain the smallest number of blocks possible without duplicating
    bytes.

    :param interval:  byte interval to split
    :param alignment:  optional table of alignments for blocks and intervals
    :param tables:  optional collection of offset mappings to update
    :returns:  list of byte intervals containing the blocks in the original
        interval
    """
    ...

def join_byte_intervals(intervals: List[gtirb.ByteInterval], nop: Optional[bytes] = ..., alignment: Optional[Mapping[gtirb.Node, int]] = ..., tables: Optional[Iterable[OffsetMapping[object]]] = ...) -> gtirb.ByteInterval:
    """Concatenate a list of byte intervals.

    The first interval in the given list will be trated as the destination. The
    contents (bytes and byte_blocks) of all other intervals will be
    concatenated onto the end of the destination interval in the order they
    appear in the list.

    Padding will be inserted between subsequent intervals so that the address
    of the first block of each interval (or of the interval itself if it
    contains no blocks) is properly aligned. Addresses are calculated based on
    the address of the destination block, or 0 if it has no address. If the
    alignment mapping is not specified, the "alignment" aux data for each
    interval's module, if any, will be used.

    The symbolic expressions will be transfered to the destination module,
    adjusted to retain their positions relative to their original byte
    interval. In addition, any tables given will be updated by relocating
    Offsets into each concatenated interval to refer to the corresponding
    Offset into the destination interval. If no tables are provided, a default
    set of aux data will be updated; pass an empty sequence of tables to
    prevent any tables from being updated.

    NB: This function destructively removes the blocks, bytes, and symbolic
    expressions from the other intervals when they are added to the
    destination, but it does not remove the intervals from their sections.

    :param intervals:  list of byte intervals to concatenate
    :param nop:  bytes representing a single nop instruction
    :param alignment:  table of alignments for blocks and intervals
    :param tables:  collection of offset mappings to update
    """
    ...

