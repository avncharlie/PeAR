"""
This type stub file was generated by pyright.
"""

import dataclasses
import pathlib
import gtirb
import gtirb_functions
from typing import Iterable, List, NamedTuple, Optional, Sequence, Tuple, Union, overload
from gtirb_capstone.instructions import GtirbInstructionDecoder
from .patch import Patch
from .scopes import Scope

class UnresolvableScopeError(ValueError):
    """
    The scope passed to register_insert cannot be resolved or is invalid.
    """
    ...


@dataclasses.dataclass
class _Modification:
    id: int
    scope: Scope
    ...


@dataclasses.dataclass
class _InsertionOrReplacement(_Modification):
    patch: Union[Patch, bytes]
    ...


@dataclasses.dataclass
class _Deletion(_Modification):
    retarget_to_proxy: bool
    ...


class _FunctionInsertion(NamedTuple):
    symbol: gtirb.Symbol
    block: gtirb.CodeBlock
    patch: Patch
    ...


class _ModificationStore:
    """
    Maintains the list of modifications and resolves them to concrete offsets
    when applying them.
    """
    def __init__(self) -> None:
        ...
    
    def add(self, modification: _Modification) -> None:
        """
        Registers a modification.
        """
        ...
    
    def modifications_for_block(self, module: gtirb.Module, block: gtirb.ByteBlock, func: Optional[gtirb_functions.Function]) -> List[_Modification]:
        """
        Finds all modifications that apply to a given block.
        """
        ...
    
    def resolve_offsets(self, block: gtirb.ByteBlock, decoder: GtirbInstructionDecoder, modifications: Iterable[_Modification]) -> List[Tuple[_Modification, int]]:
        """
        Determines the concrete offsets into the block that each modification
        should be applied. The returned list will be in the order that the
        patches should be applied.
        """
        ...
    


class _CFIProcedureTracker:
    """
    Keeps track of whether or not a given offset is in a CFI procedure.
    """
    def __init__(self, module: gtirb.Module, sorted_blocks: List[gtirb.ByteBlock]) -> None:
        ...
    
    def in_procedure(self, block_idx: int, offset: int) -> bool:
        ...
    


class RewritingContext:
    """
    A rewriting context manages insertions and modifications on a single
    module. It takes care of resolving insertion scopes to concrete positions,
    potentially trying to bubble multiple insertions together for performance.
    """
    def __init__(self, module: gtirb.Module, functions: Sequence[gtirb_functions.Function], logger=..., expensive_assertions=...) -> None:
        """
        :param module: The module to rewrite.
        :param functions: The list of functions in the module.
        :param logger: The logger to log to when rewriting.
        :param expensive_assertions: If enabled, extra assertions will be
        enabled that may have noticable run-time overhead.
        """
        ...
    
    def get_or_insert_extern_symbol(self, name: str, libname: str, preload: bool = ..., libpath: Union[str, pathlib.Path, None] = ...) -> gtirb.Symbol:
        """
        Gets a symbol by name, creating it as an extern symbol if it isn't
        already in the module.
        :param name: The name of the symbol.
        :param libname: The name of the shared library the symbol is from.
        :param preload: Insert the library dependency at the beginning of the
                        libraries aux data table, similar to LD_PRELOAD. ELF
                        only, optional.
        :param libpath: Additional path to search for libname at runtime.
        """
        ...
    
    def register_insert(self, scope: Scope, patch: Patch) -> None:
        """
        Registers a patch to be inserted.
        :param scope: Where should the patch be placed?
        :param patch: The patch to be inserted.
        """
        ...
    
    def register_insert_function(self, name: str, patch: Patch) -> gtirb.Symbol:
        """
        Registers a patch to be inserted as a function.
        :param name: The name of the function to be inserted.
        :param patch: The patch to be inserted.
        :returns: The new function symbol.
        """
        ...
    
    @overload
    def insert_at(self, block: gtirb.CodeBlock, offset: int, patch: Patch) -> None:
        """
        Inserts a patch at a specific location in the binary. This is not
        subject to bubbling.
        """
        ...
    
    @overload
    def insert_at(self, block: gtirb.DataBlock, offset: int, patch: Union[Patch, bytes]) -> None:
        """
        Inserts a patch at a specific location in the binary.
        """
        ...
    
    @overload
    def insert_at(self, function: gtirb_functions.Function, block: gtirb.CodeBlock, offset: int, patch: Patch) -> None:
        "Deprecated variant of insert_at that takes a function."
        ...
    
    def insert_at(self, *args, **kwargs) -> None:
        ...
    
    @overload
    def replace_at(self, block: gtirb.CodeBlock, offset: int, length: int, patch: Patch) -> None:
        """
        Inserts a patch at a specific code block in the binary, replacing the
        instructions as specified. This is not subject to bubbling.
        """
        ...
    
    @overload
    def replace_at(self, block: gtirb.DataBlock, offset: int, length: int, patch: Union[Patch, bytes]) -> None:
        """
        Inserts a patch or bytes at a specific data block in the binary,
        replacing the instructions as specified.
        """
        ...
    
    @overload
    def replace_at(self, function: gtirb_functions.Function, block: gtirb.CodeBlock, offset: int, length: int, patch: Patch) -> None:
        """
        Deprecated variant of replace_at that takes a function.
        """
        ...
    
    def replace_at(self, *args, **kwargs) -> None:
        ...
    
    def delete_function(self, function: gtirb_functions.Function): # -> None:
        """
        Deletes an entire function, replacing references to its blocks with
        references to proxy blocks.
        """
        ...
    
    def delete_at(self, block: gtirb.ByteBlock, offset: int, length: int, *, retarget_to_proxy: bool = ...): # -> None:
        """
        Deletes part or all of a block. If deleting a whole block, labels and
        control flow referring to the deleted block will be changed to refer
        to the 'next' block.

        The next block is calculated from a combination of the CFG and block
        addresses. If the block has an outgoing fallthrough edge, the edge's
        target is used. Otherwise the code block with the next address after
        the end of this block is used. If no block can be found, an exception
        is raised.

        Alternatively, specifying retarget_to_proxy when deleting a whole
        block will make the 'next' block just be a proxy block. Specifying
        retarget_to_proxy in other situations will raise a ValueError.
        """
        ...
    
    def apply(self) -> None:
        """
        Applies all of the patches to the module.
        """
        ...
    


