"""
This type stub file was generated by pyright.
"""

import uuid
import gtirb
from typing import Any, Dict, Iterator, MutableMapping, MutableSet, Optional, TypeVar, Union, overload

T = TypeVar("T")
ElementT = Union[uuid.UUID, gtirb.Node]
T2 = TypeVar("T2")
class OffsetMapping(MutableMapping[gtirb.Offset, T]):
    """Mapping that allows looking up groups of items by their offset element.

    The keys in this mapping are required to be Offsets. If a non-Offset is
    used as a key, it is assumed to be the element_id of an Offset. In that
    case, the corresponding element is a MutableMapping[int, T] of
    displacements to values for every Offset that has the given element_id.

    Examples:
    >>> m = OffsetMapping[str]()
    >>> m[Offset(x, 0)] = "a"     # insert an offset into the map
    >>> m[x] = {1: "b", 2: "c"}   # set all of the offsets associated with x,
    >>> 0 in m[x]                 # dropping any other values for x
    False
    >>> m[x][1] = "d"             # change the value for Offset(x, 1)
    >>> m[Offset(x, 1)]           # get the value for Offset(x, 1)
    'd'
    >>> del m[Offset(x, 2)]       # delete Offset(x, 2) from the map
    """
    def __init__(self, *args, **kw) -> None:
        """Create a new OffsetMapping from an iterable and/or keywords."""
        ...
    
    def __bool__(self) -> bool:
        ...
    
    def __len__(self) -> int:
        """Get the number of Offsets stored in this mapping."""
        ...
    
    def __iter__(self) -> Iterator[gtirb.Offset]:
        """ "Yield the Offsets in this mapping."""
        ...
    
    def node_keys(self) -> Iterator[ElementT]:
        ...
    
    @overload
    def __getitem__(self, key: gtirb.Offset) -> T:
        ...
    
    @overload
    def __getitem__(self, key: ElementT) -> Dict[int, T]:
        ...
    
    def __getitem__(self, key): # -> T | MutableMapping[int, T]:
        """Get the value for an Offset or dictionary for an element_id."""
        ...
    
    @overload
    def __setitem__(self, key: gtirb.Offset, value: T) -> None:
        ...
    
    @overload
    def __setitem__(self, key: ElementT, value: MutableMapping[int, T]) -> None:
        ...
    
    def __setitem__(self, key, value): # -> None:
        """Set the value for an Offset, or all Offsets for an element."""
        ...
    
    def __delitem__(self, key: Union[gtirb.Offset, ElementT]) -> None:
        """Delete the mapping for an Offset or all Offsets given an element."""
        ...
    
    def __contains__(self, key: object) -> bool:
        """
        Determines if the mapping contains a given Offset or any offset for a
        given element.
        """
        ...
    
    @overload
    def get(self, key: gtirb.Offset) -> Union[T, None]:
        ...
    
    @overload
    def get(self, key: gtirb.Offset, default: T2) -> Union[T, T2]:
        ...
    
    @overload
    def get(self, key: ElementT) -> Union[Dict[int, T], None]:
        ...
    
    @overload
    def get(self, key: ElementT, default: T2) -> Union[Dict[int, T], T2]:
        ...
    
    def get(self, *args, **kwargs) -> Any:
        ...
    
    @overload
    def pop(self, key: gtirb.Offset) -> T:
        ...
    
    @overload
    def pop(self, key: gtirb.Offset, default: T2) -> Union[T, T2]:
        ...
    
    @overload
    def pop(self, key: ElementT) -> Dict[int, T]:
        ...
    
    @overload
    def pop(self, key: ElementT, default: T2) -> Union[Dict[int, T], T2]:
        ...
    
    def pop(self, *args, **kwargs) -> Any:
        ...
    
    @overload
    def setdefault(self, key: gtirb.Offset, default: T) -> T:
        ...
    
    @overload
    def setdefault(self, key: ElementT, default: Dict[int, T]) -> Dict[int, T]:
        ...
    
    def setdefault(self, *args, **kwargs) -> Any:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class _IdentitySet(MutableSet[T]):
    """
    A set that uses object identity instead of __hash__/__eq__.
    """
    def __init__(self, iterable=...) -> None:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __iter__(self) -> Iterator[T]:
        ...
    
    def __contains__(self, x: T) -> bool:
        ...
    
    def add(self, value: T) -> None:
        ...
    
    def discard(self, value: T) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    


def show_block_asm(block: gtirb.ByteBlock, arch: Optional[gtirb.Module.ISA] = ..., logger=..., decoder=...) -> None:
    """
    Disassemble and print the contents of a code block using the given
    architecture. If no architecture is given, it is taken from the block's
    module. If the block is not in a module, the function throws an error.
    """
    ...

def decorate_extern_symbol(module: gtirb.Module, sym: str) -> str:
    """
    Decorates a symbol as needed for the target. For example, this might
    involve adding a leading underscore on some platforms.
    """
    ...

def effective_alignment(address: int, max_alignment: int = ...) -> int:
    """Return the largest power of two to which an address is aligned."""
    ...

def align_address(address: int, alignment: int) -> int:
    """Increase an address to the next alignment boundary, if necessary."""
    ...

