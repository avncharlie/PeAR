"""
This type stub file was generated by pyright.
"""

import typing
from enum import Enum
from uuid import UUID
from .node import Node
from .byteinterval import ByteInterval
from .cfg import Edge
from .ir import IR
from .module import Module
from .section import Section
from .symbol import Symbol

if typing.TYPE_CHECKING:
    ...
class Block(Node):
    """The base class for blocks. Symbols may have references to any subclass
    of Block.
    """
    @property
    def references(self) -> typing.Iterator[Symbol]:
        """Get all the symbols that refer to this block."""
        ...
    


class ByteBlock(Block):
    """The base class for blocks that belong to a :class:`ByteInterval` and
    store their bytes there.

    :ivar ~.size: The size of the block in bytes.
    :ivar ~.offset: The offset from the beginning of the byte interval to which
        this block belongs. Multiple blocks in the same interval may have the
        same offset.
    """
    size = ...
    offset = ...
    def __init__(self, *, size: int = ..., offset: int = ..., uuid: typing.Optional[UUID] = ..., byte_interval: typing.Optional[ByteInterval] = ...) -> None:
        """
        :param size: The size of the data object in bytes.
        :param offset: The offset from the beginning of the byte interval to
            which this block belongs.
        :param uuid: The UUID of this ``ByteBlock``,
            or None if a new UUID needs generated via :func:`uuid.uuid4`.
            Defaults to None.
        :param byte_interval: The :class:`ByteInterval` this block belongs to.
        """
        ...
    
    @property
    def byte_interval(self) -> typing.Optional[ByteInterval]:
        """The :class:`ByteInterval` this block belongs to."""
        ...
    
    @byte_interval.setter
    def byte_interval(self, value: typing.Optional[ByteInterval]) -> None:
        ...
    
    def deep_eq(self, other: object) -> bool:
        ...
    
    @property
    def contents(self) -> bytes:
        """Get the bytes in this block."""
        ...
    
    @property
    def address(self) -> typing.Optional[int]:
        """Get the address of this block, or None if not present."""
        ...
    
    @property
    def references(self) -> typing.Iterator[Symbol]:
        ...
    
    @property
    def section(self) -> typing.Optional[Section]:
        """Get the section this node ultimately belongs to."""
        ...
    
    @property
    def module(self) -> typing.Optional[Module]:
        """Get the module this node ultimately belongs to."""
        ...
    
    @property
    def ir(self) -> typing.Optional[IR]:
        """Get the IR this node ultimately belongs to."""
        ...
    
    def contains_offset(self, offset: int) -> bool:
        """Indicate if the provided offset is within this block."""
        ...
    
    def contains_address(self, address: int) -> bool:
        """Indicate if the provided address is within this block.
        Returns False if the block has no address.
        """
        ...
    


class CfgNode(Block):
    """The base class for blocks that may appear as vertices in the CFG."""
    @property
    def incoming_edges(self) -> typing.Iterable[Edge]:
        """Get the edges that point to this CFG node."""
        ...
    
    @property
    def outgoing_edges(self) -> typing.Iterable[Edge]:
        """Get the edges that start at this CFG node."""
        ...
    


class DataBlock(ByteBlock):
    """Represents a data object, possibly symbolic."""
    def __init__(self, *, size: int = ..., offset: int = ..., uuid: typing.Optional[UUID] = ..., byte_interval: typing.Optional[ByteInterval] = ...) -> None:
        """
        :param size: The size of the data object in bytes.
        :param offset: The offset from the beginning of the byte interval to
            which this block belongs.
        :param uuid: The UUID of this ``DataBlock``,
            or None if a new UUID needs generated via :func:`uuid.uuid4`.
            Defaults to None.
        :param byte_interval: The :class:`ByteInterval` this block belongs to.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


class CodeBlock(ByteBlock, CfgNode):
    """A basic block in the binary.

    Does not directly store data bytes, which are kept in a
    :class:`ByteInterval`.

    :ivar ~.decode_mode: The decode mode of the block,
        used in some ISAs to differentiate between sub-ISAs
        (e.g. differentiating blocks written in ARM and Thumb).
    """
    class DecodeMode(Enum):
        """Variations on decoding a particular ISA"""
        Default = ...
        Thumb = ...
    
    
    def __init__(self, *, decode_mode: DecodeMode = ..., size: int = ..., offset: int = ..., uuid: typing.Optional[UUID] = ..., byte_interval: typing.Optional[ByteInterval] = ...) -> None:
        """
        :param size: The length of the block in bytes.
        :param decode_mode: The decode mode of the block,
            used in some ISAs to differentiate between sub-ISAs
            (e.g. differentiating blocks written in ARM and Thumb).
            Defaults to DecodeMode.Default.
        :param offset: The offset from the beginning of the byte interval to
            which this block belongs.
        :param uuid: The UUID of this ``CodeBlock``,
            or None if a new UUID needs generated via :func:`uuid.uuid4`.
            Defaults to None.
        :param byte_interval: The :class:`ByteInterval` this block belongs to.
        """
        ...
    
    def deep_eq(self, other: object) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def incoming_edges(self) -> typing.Iterator[Edge]:
        ...
    
    @property
    def outgoing_edges(self) -> typing.Iterator[Edge]:
        ...
    


class ProxyBlock(CfgNode):
    """A placeholder that serves as the endpoint (source or target) of a
    :class:`gtirb.Edge`.

    ProxyBlock objects allow the construction of CFG edges to or from
    another node. For example, a call to a function in another module
    may be represented by a :class:`gtirb.Edge` that originates at the
    calling :class:`gtirb.CodeBlock` and targets a ProxyBlock. Another
    example would be a :class:`gtirb.Edge` that represents an indirect
    jump whose target is not known.

    A ProxyBlock does not represent any instructions and so has neither
    an address nor a size.
    """
    def __init__(self, *, uuid: typing.Optional[UUID] = ..., module: typing.Optional[Module] = ...) -> None:
        ...
    
    def deep_eq(self, other: object) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def module(self) -> typing.Optional[Module]:
        ...
    
    @module.setter
    def module(self, value: typing.Optional[Module]) -> None:
        ...
    
    @property
    def references(self) -> typing.Iterator[Symbol]:
        ...
    
    @property
    def incoming_edges(self) -> typing.Iterator[Edge]:
        ...
    
    @property
    def outgoing_edges(self) -> typing.Iterator[Edge]:
        ...
    
    @property
    def ir(self) -> typing.Optional[IR]:
        """Get the IR this node ultimately belongs to."""
        ...
    


