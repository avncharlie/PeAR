"""
This type stub file was generated by pyright.
"""

import typing
import typing_extensions

"""General utilities usable by any other GTIRB submoudle."""
K = typing.TypeVar("K")
V = typing.TypeVar("V")
T = typing.TypeVar("T")
T_cov = typing.TypeVar("T_cov", covariant=True)
T_contra = typing.TypeVar("T_contra", contravariant=True)
S = typing.TypeVar("S")
DictLike = typing.Union[typing.Mapping[K, V], typing.Iterable[typing.Tuple[K, V]],]
class GtirbError(Exception):
    ...


class DeserializationError(GtirbError):
    ...


class _SymbolicExpressionContainer(typing_extensions.Protocol[T_cov]):
    """A container of symbolic expressions at addresses."""
    def symbolic_expressions_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[T_cov]:
        ...
    


class ListWrapper(typing.MutableSequence[T]):
    def __init__(self, *args: typing.Iterable[T]) -> None:
        ...
    
    @typing.overload
    def __getitem__(self, i: int) -> T:
        ...
    
    @typing.overload
    def __getitem__(self, i: slice) -> typing.MutableSequence[T]:
        ...
    
    def __getitem__(self, i: typing.Union[int, slice]) -> typing.Union[T, typing.MutableSequence[T]]:
        ...
    
    @typing.overload
    def __setitem__(self, i: typing_extensions.SupportsIndex, v: T) -> None:
        ...
    
    @typing.overload
    def __setitem__(self, i: slice, v: typing.Iterable[T]) -> None:
        ...
    
    def __setitem__(self, i: typing.Union[typing_extensions.SupportsIndex, slice], v: typing.Union[T, typing.Iterable[T]]) -> None:
        ...
    
    @typing.overload
    def __delitem__(self, i: int) -> None:
        ...
    
    @typing.overload
    def __delitem__(self, i: slice) -> None:
        ...
    
    def __delitem__(self, i: typing.Union[int, slice]) -> None:
        ...
    
    def __len__(self) -> int:
        ...
    
    def insert(self, i: int, v: T) -> None:
        ...
    
    def append(self, v: T) -> None:
        ...
    
    def remove(self, v: T) -> None:
        ...
    
    def extend(self, other: typing.Iterable[T]) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    


_SetWrapperSelf = typing.TypeVar("_SetWrapperSelf", bound="SetWrapper[typing.Any]")
class SetWrapper(typing.MutableSet[T]):
    def __init__(self, *args: typing.Iterable[T]) -> None:
        ...
    
    def __contains__(self, v: object) -> bool:
        ...
    
    def __iter__(self) -> typing.Iterator[T]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def add(self, v: T) -> None:
        ...
    
    def discard(self, v: T) -> None:
        ...
    
    def __or__(self, other: typing.AbstractSet[S]) -> typing.Set[typing.Union[T, S]]:
        ...
    
    def __ior__(self: _SetWrapperSelf, other: typing.AbstractSet[T]) -> _SetWrapperSelf:
        ...
    
    def pop(self) -> T:
        ...
    
    def clear(self) -> None:
        ...
    
    def update(self, *others: typing.Iterable[T]) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    


class DictWrapper(typing.MutableMapping[K, V]):
    def __init__(self, *args: DictLike[K, V]) -> None:
        ...
    
    def __getitem__(self, i: K) -> V:
        ...
    
    def __setitem__(self, i: K, v: V) -> None:
        ...
    
    def __delitem__(self, i: K) -> None:
        ...
    
    def __iter__(self) -> typing.Iterator[K]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    


InstanceT = typing.TypeVar("InstanceT")
AttributeT = typing.TypeVar("AttributeT")
class IndexedContainer(typing_extensions.Protocol[T_contra]):
    """Container wth an index that can be updated."""
    ...


class ParentGetter(typing_extensions.Protocol[T_contra]):
    """Interface for getting an _IndexedContainer for an instance."""
    def __call__(self, instance: T_contra) -> typing.Optional[IndexedContainer[T_contra]]:
        ...
    


class _IndexedAttribute(typing.Generic[AttributeT]):
    """
    The _IndexedAttribute descriptor notifies a parent when the attribute is
    modified. The outer class is generic in the attribute type and provides a
    __call__ method to deduce the remaining type parameters and construct the
    descriptor itself.

    Example usage:

    class Foo:
        my_int = _IndexedAttribute[int]()(lambda foo: foo.parent)
    """
    class Descriptor(typing.Generic[InstanceT]):
        """
        A descriptor that will notify a parent when the value is set and can be
        otherwise used like a normal attribute.
        """
        def __init__(self, parent_getter: ParentGetter[InstanceT]) -> None:
            ...
        
        def __get__(self, instance: InstanceT, owner: typing.Type[InstanceT] = ...) -> AttributeT:
            ...
        
        def __set__(self, instance: InstanceT, value: AttributeT) -> None:
            ...
        
        def __delete__(self, instance: InstanceT) -> None:
            ...
        
        def __set_name__(self, owner: InstanceT, name: str) -> None:
            ...
        
    
    
    def __call__(self, parent_getter: ParentGetter[InstanceT]) -> AttributeT:
        """
        Create the descriptor, but tell mypy it is the attribute type.

        The cast helps mypy recognize when the instance type satisfies a
        protocol. Mypy checks to see if the class matches the protocol instead
        of the instance. However, descriptors are treated as the descriptor
        type in the class and the attribute type in the instance. This causes
        mypy to reject the protocol, even though it works correctly at runtime.
        """
        ...
    


def get_desired_range(addrs: typing.Union[int, range]) -> range:
    ...

class AddrRange(typing_extensions.Protocol):
    """An object spanning a range of addresses."""
    @property
    def address(self) -> typing.Optional[int]:
        ...
    
    @property
    def size(self) -> typing.Optional[int]:
        ...
    


AddrRangeT = typing.TypeVar("AddrRangeT", bound=AddrRange)
def nodes_on(nodes: typing.Iterable[AddrRangeT], addrs: typing.Union[int, range]) -> typing.Iterable[AddrRangeT]:
    ...

def nodes_at(nodes: typing.Iterable[AddrRangeT], addrs: typing.Union[int, range]) -> typing.Iterable[AddrRangeT]:
    ...

class OffsetRange(typing_extensions.Protocol):
    """An object spanning a range of offsets."""
    @property
    def offset(self) -> int:
        ...
    
    @property
    def size(self) -> int:
        ...
    


OffsetRangeT = typing.TypeVar("OffsetRangeT", bound=OffsetRange)
def symbolic_expressions_at(nodes: typing.Iterable[_SymbolicExpressionContainer[T_cov]], addrs: typing.Union[int, range]) -> typing.Iterable[T_cov]:
    ...

