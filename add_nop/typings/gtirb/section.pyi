"""
This type stub file was generated by pyright.
"""

import typing
from enum import Enum
from uuid import UUID
from .block import ByteBlock, CodeBlock, DataBlock
from .byteinterval import ByteInterval, SymbolicExpressionElement
from .node import Node
from .util import SetWrapper
from .ir import IR
from .module import Module

if typing.TYPE_CHECKING:
    ...
class Section(Node):
    """Represents a named section of the binary.

    Does not directly store the contents of the section, which are
    kept in a :class:`gtirb.ImageByteMap`.

    :ivar ~.name: The section name (E.g. ".text", ".bss", etc).
    :ivar ~.byte_intervals: The :class:`ByteInterval`\\s in this section.
    :ivar ~.flags: The :class:`Section.Flag`\\s this section has.
    """
    class Flag(Enum):
        """A flag representing a known property of a section."""
        Undefined = ...
        Readable = ...
        Writable = ...
        Executable = ...
        Loaded = ...
        Initialized = ...
        ThreadLocal = ...
    
    
    class _ByteIntervalSet(SetWrapper[ByteInterval]):
        def __init__(self, node: Section, *args: typing.Iterable[ByteInterval]) -> None:
            ...
        
        def add(self, v: ByteInterval) -> None:
            ...
        
        def discard(self, v: ByteInterval) -> None:
            ...
        
    
    
    def __init__(self, *, name: str = ..., byte_intervals: typing.Iterable[ByteInterval] = ..., flags: typing.Iterable[Section.Flag] = ..., uuid: typing.Optional[UUID] = ..., module: typing.Optional[Module] = ...) -> None:
        """
        :param name: The name of this section.
        :param byte_intervals: The :class:`ByteInterval`\\s in this section.
        :param flags: The :class:`Section.Flag`\\s this section has.
        :param uuid: The UUID of this ``Section``,
            or None if a new UUID needs generated via :func:`uuid.uuid4`.
            Defaults to None.
        :param module: The :class:`Module` this section belongs to.
        """
        ...
    
    def deep_eq(self, other: object) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def module(self) -> typing.Optional[Module]:
        """The :class:`Module` this section belongs to."""
        ...
    
    @module.setter
    def module(self, value: typing.Optional[Module]) -> None:
        ...
    
    @property
    def byte_blocks(self) -> typing.Iterator[ByteBlock]:
        """The :class:`ByteBlock`\\s in this section."""
        ...
    
    @property
    def code_blocks(self) -> typing.Iterator[CodeBlock]:
        """The :class:`CodeBlock`\\s in this section."""
        ...
    
    @property
    def data_blocks(self) -> typing.Iterator[DataBlock]:
        """The :class:`DataBlock`\\s in this section."""
        ...
    
    @property
    def address(self) -> typing.Optional[int]:
        """Get the address of this section, if known.

        The address is calculated from the :class:`ByteInterval` objects in
        this section. More specifically, if the address of all byte intervals
        in this section are fixed, then it will return the address of the
        interval lowest in memory. If any one interval does not have an address
        then this will be ``None``, as the address is not calculable in that
        case. Note that a section with no intervals in it has no address or
        size, so it will be ``None`` in that case.
        """
        ...
    
    @property
    def size(self) -> typing.Optional[int]:
        """Get the size of this section, if known.

        The address is calculated from the :class:`ByteInterval` objects in
        this section. More specifically, if the address of all byte intervals
        in this section are fixed, then it will return the difference between
        the lowest and highest address among the intervals. If any one interval
        does not have an address, then this will be ``None``, as the size is
        not calculable in that case. Note that a section with no intervals in
        it has no address or size, so it will be ``None`` in that case.
        """
        ...
    
    def byte_intervals_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteInterval]:
        """Finds all the byte intervals that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def byte_intervals_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteInterval]:
        """Finds all the byte intervals that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def byte_blocks_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteBlock]:
        """Finds all the byte blocks that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def byte_blocks_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteBlock]:
        """Finds all the byte blocks that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def code_blocks_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[CodeBlock]:
        """Finds all the code blocks that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def code_blocks_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[CodeBlock]:
        """Finds all the code blocks that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def data_blocks_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[DataBlock]:
        """Finds all the data blocks that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def data_blocks_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[DataBlock]:
        """Finds all the data blocks that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def symbolic_expressions_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[SymbolicExpressionElement]:
        """Finds all the symbolic expressions that begin at an address or
        range of addresses.

        :param addrs: Either a ``range`` object or a single address.
        :returns: Yields ``(interval, offset, symexpr)`` tuples for every
            symbolic expression in the range.
        """
        ...
    
    @property
    def ir(self) -> typing.Optional[IR]:
        """Get the IR this node ultimately belongs to."""
        ...
    


