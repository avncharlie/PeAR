"""
This type stub file was generated by pyright.
"""

import typing
from uuid import UUID
from .block import ByteBlock, CodeBlock, DataBlock
from .node import Node
from .symbolicexpression import SymbolicExpression
from .util import DictLike, DictWrapper, SetWrapper
from .ir import IR
from .module import Module
from .section import Section

if typing.TYPE_CHECKING:
    ...
SymbolicExpressionElement = typing.Tuple["ByteInterval", int, SymbolicExpression]
class ByteInterval(Node):
    """A contiguous region of bytes in a binary.

    A ByteInterval defines a relative ordering for a group of
    :class:`ByteBlock`\\s, optionally at a fixed address in memory. It also
    stores the bytes associated with these blocks.

    If two blocks are in two different ByteIntervals, then it should be
    considered safe (that is, preserving of program semantics) to move one
    block relative to the other in memory. If two blocks are in the same
    ByteInterval, then it should be considered unknown if moving the two blocks
    relative to one another in memory is a safe operation.

    :ivar ~.address: The fixed address of this interval, if present. If this
        field is present, it may indicate the original address at which this
        interval was located at in memory, or it may indicate that this block's
        address is fixed and must not be changed. If this field is not present,
        it indicates that the interval is free to be moved around in memory
        while preserving program semantics.
    :ivar ~.size: The size of this interval in bytes. If this number is greater
        than ``initialized_size``, this indicates that the high addresses taken
        up by this interval consist of uninitialized bytes. This often occurs
        in BSS sections, where data is zero-initialized rather than stored as
        zeroes in the binary.
    :ivar ~.contents: The bytes stored in this interval.
    :ivar ~.blocks: A set of all :class:`ByteBlock`\\s in this interval.
    :ivar ~.symbolic_expressions: A mapping, from offset in the interval, to a
        :class:`SymbolicExpression` in the interval.
    """
    class _BlockSet(SetWrapper[ByteBlock]):
        def __init__(self, node: ByteInterval, *args: typing.Iterable[ByteBlock]) -> None:
            ...
        
        def add(self, v: ByteBlock) -> None:
            ...
        
        def update(self, *iterables: typing.Iterable[ByteBlock]) -> None:
            ...
        
        def discard(self, v: ByteBlock) -> None:
            ...
        
    
    
    class _SymbolicExprDict(DictWrapper[int, SymbolicExpression]):
        def __init__(self, interval: ByteInterval, *args: DictLike[int, SymbolicExpression]) -> None:
            ...
        
        def __repr__(self) -> str:
            ...
        
    
    
    address = ...
    size = ...
    def __init__(self, *, address: typing.Optional[int] = ..., size: typing.Optional[int] = ..., initialized_size: typing.Optional[int] = ..., contents: typing.ByteString = ..., blocks: typing.Iterable[ByteBlock] = ..., symbolic_expressions: DictLike[int, SymbolicExpression] = ..., uuid: typing.Optional[UUID] = ..., section: typing.Optional[Section] = ...) -> None:
        """
        :param address: The fixed address of this interval, if present.
        :param size: The size of this interval in bytes.
        :param initialized_size: The number of initialized bytes in this
            interval.
        :param contents: The bytes stored in this interval.
        :param blocks: A set of all :class:`ByteBlock`\\s in this interval.
        :param symbolic_expressions: A mapping, from offset in the interval, to
            a :class:`SymbolicExpression` in the interval.
        :param uuid: The UUID of this ``ByteInterval``,
            or None if a new UUID needs generated via :func:`uuid.uuid4`.
            Defaults to None.
        :param section: The :class:`Section` this interval belongs to.
        """
        ...
    
    @property
    def initialized_size(self) -> int:
        """The number of initialized bytes in this interval.

        Not all bytes in this interval may correspond to bytes physically
        stored in the underlying file format. This can occur, for example, in
        BSS sections, which are zero-initialized at loadtime, but these zeroes
        are not stored in the file itself. If this number is smaller than
        ``size``, this indicates that any bytes past this number are
        unitialized bytes with values determined at loadtime. As such, all
        bytes past this number in this interval's byte vector are truncated
        when saving to file.
        """
        ...
    
    @initialized_size.setter
    def initialized_size(self, value: int) -> None:
        ...
    
    @property
    def section(self) -> typing.Optional[Section]:
        """The :class:`Section` this interval belongs to."""
        ...
    
    @section.setter
    def section(self, value: typing.Optional[Section]) -> None:
        ...
    
    @property
    def symbolic_expressions(self) -> typing.MutableMapping[int, SymbolicExpression]:
        ...
    
    @symbolic_expressions.setter
    def symbolic_expressions(self, value: typing.Dict[int, SymbolicExpression]) -> None:
        ...
    
    def deep_eq(self, other: object) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def byte_blocks_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteBlock]:
        """Finds all the byte blocks that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def byte_blocks_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteBlock]:
        """Finds all the byte blocks that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def code_blocks_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[CodeBlock]:
        """Finds all the code blocks that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def code_blocks_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[CodeBlock]:
        """Finds all the code blocks that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def data_blocks_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[DataBlock]:
        """Finds all the data blocks that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def data_blocks_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[DataBlock]:
        """Finds all the data blocks that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def symbolic_expressions_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[SymbolicExpressionElement]:
        """Finds all the symbolic expressions that begin at an address or
        range of addresses.

        :param addrs: Either a ``range`` object or a single address.
        :returns: Yields ``(interval, offset, symexpr)`` tuples for every
            symbolic expression in the range.
        """
        ...
    
    @property
    def module(self) -> typing.Optional[Module]:
        """Get the module this node ultimately belongs to."""
        ...
    
    @property
    def ir(self) -> typing.Optional[IR]:
        """Get the IR this node ultimately belongs to."""
        ...
    


