"""
This type stub file was generated by pyright.
"""

import typing
from enum import Enum
from uuid import UUID
from .auxdata import AuxData, AuxDataContainer
from .block import ByteBlock, CfgNode, CodeBlock, DataBlock, ProxyBlock
from .byteinterval import ByteInterval, SymbolicExpressionElement
from .section import Section
from .symbol import Symbol
from .util import DictLike, SetWrapper
from .ir import IR

if typing.TYPE_CHECKING:
    ...
_T = typing.TypeVar("_T", bound=typing.Union[ProxyBlock, Section, Symbol])
class Module(AuxDataContainer):
    """Represents a loadable object, such as an executable or library.

    :ivar ~.binary_path: The path to the loadable binary object
        represented by this module. An empty string if not specified.
        The file represented by this path is indicitave of what file
        this ``Module`` was initially created from; it is not guaranteed to
        currently exist or have the same contents.
    :ivar ~.isa: The ISA of the binary.
    :ivar ~.file_format: The file format of the binary.
    :ivar ~.byte_order: The endianness of the binary.
    :ivar ~.name: The name given to the binary. Some file formats use this
        for linking and/or symbol resolution purposes. The file name (without
        directory components) if not specified by the format.
    :ivar ~.preferred_addr: The preferred loading address of the binary.
    :ivar ~.proxies: A set containing all the :class:`gtirb.ProxyBlock`\\s
        in the binary.
    :ivar ~.rebase_delta: The rebase delta of the binary.
    :ivar ~.sections: A set containing all the :class:`gtirb.Section`\\s
        in the binary.
    :ivar ~.symbols: A set containing all the :class:`gtirb.Symbol`\\s
        in the binary.
    :ivar ~.entry_point: A :class:`CodeBlock` representing where
        control flow of this module begins at, or None if not present.
    """
    class FileFormat(Enum):
        """Identifies the executable file format of the binary represented
        by a :class:`gtirb.Module`.
        """
        Undefined = ...
        COFF = ...
        ELF = ...
        IdaProDb32 = ...
        IdaProDb64 = ...
        MACHO = ...
        PE = ...
        RAW = ...
        XCOFF = ...
    
    
    class ISA(Enum):
        """Identifies the instruction set architecture (ISA)
        targeted by a :class:`gtirb.Module`.
        """
        Undefined = ...
        ARM = ...
        ARM64 = ...
        IA32 = ...
        PPC32 = ...
        PPC64 = ...
        MIPS32 = ...
        MIPS64 = ...
        X64 = ...
        ValidButUnsupported = ...
    
    
    class ByteOrder(Enum):
        """Identifies the endianness of a :class:`gtirb.Module`."""
        Undefined = ...
        Big = ...
        Little = ...
    
    
    class _NodeSet(SetWrapper[_T]):
        def __init__(self, node: Module, field: str, *args: typing.Iterable[_T]) -> None:
            ...
        
        def add(self, v: _T) -> None:
            ...
        
        def discard(self, v: _T) -> None:
            ...
        
    
    
    def __init__(self, *, name: str, aux_data: DictLike[str, AuxData] = ..., binary_path: str = ..., file_format: FileFormat = ..., isa: ISA = ..., byte_order: ByteOrder = ..., preferred_addr: int = ..., proxies: typing.Iterable[ProxyBlock] = ..., rebase_delta: int = ..., sections: typing.Iterable[Section] = ..., symbols: typing.Iterable[Symbol] = ..., entry_point: typing.Optional[CodeBlock] = ..., uuid: typing.Optional[UUID] = ..., ir: typing.Optional[IR] = ...) -> None:
        """
        :param aux_data: The initial auxiliary data to be associated
            with the object, as a mapping from names to
            :class:`gtirb.AuxData`, defaults to an empty :class:`dict`.
        :param binary_path: The path to the loadable binary object
            represented by this module.
        :param isa: The ISA of the binary.
        :param byte_order: The endianness of the binary.
        :param file_format: The file format of the binary.
        :param name: The name given to the binary.
        :param preferred_addr: The preferred loading address of the binary.
        :param proxies: A set containing all the :class:`gtirb.ProxyBlock`\\s
            in the binary.
        :param rebase_delta: The rebase delta of the binary.
        :param sections: A set containing all the :class:`gtirb.Section`\\s
            in the binary.
        :param symbols: A set containing all the :class:`gtirb.Symbol`\\s
            in the binary.
        :param entry_point: A :class:`CodeBlock` representing where
            control flow of this module begins at, or None if not present.
        :param uuid: The UUID of this ``Module``,
            or None if a new UUID needs generated via :func:`uuid.uuid4`.
            Defaults to None.
        :param ir: The :class:`IR` this module belongs to.
        """
        ...
    
    def deep_eq(self, other: object) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def symbols_named(self, name: str) -> typing.Iterator[Symbol]:
        "Finds all symbols with a given name."
        ...
    
    @property
    def ir(self) -> typing.Optional[IR]:
        """The :class:`IR` this module belongs to."""
        ...
    
    @ir.setter
    def ir(self, value: typing.Optional[IR]) -> None:
        ...
    
    @property
    def byte_intervals(self) -> typing.Iterator[ByteInterval]:
        """The :class:`ByteInterval`\\s in this module."""
        ...
    
    @property
    def byte_blocks(self) -> typing.Iterator[ByteBlock]:
        """The :class:`ByteBlock`\\s in this module."""
        ...
    
    @property
    def code_blocks(self) -> typing.Iterator[CodeBlock]:
        """The :class:`CodeBlock`\\s in this module."""
        ...
    
    @property
    def data_blocks(self) -> typing.Iterator[DataBlock]:
        """The :class:`DataBlock`\\s in this module."""
        ...
    
    @property
    def cfg_nodes(self) -> typing.Iterator[CfgNode]:
        """The :class:`CfgNode`\\s in this module."""
        ...
    
    def sections_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[Section]:
        """Finds all the sections that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def sections_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[Section]:
        """Finds all the sections that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def byte_intervals_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteInterval]:
        """Finds all the byte intervals that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def byte_intervals_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteInterval]:
        """Finds all the byte intervals that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def byte_blocks_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteBlock]:
        """Finds all the byte blocks that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def byte_blocks_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[ByteBlock]:
        """Finds all the byte blocks that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def code_blocks_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[CodeBlock]:
        """Finds all the code blocks that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def code_blocks_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[CodeBlock]:
        """Finds all the code blocks that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def data_blocks_on(self, addrs: typing.Union[int, range]) -> typing.Iterable[DataBlock]:
        """Finds all the data blocks that overlap an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def data_blocks_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[DataBlock]:
        """Finds all the data blocks that begin at an address or range of
        addresses.

        :param addrs: Either a ``range`` object or a single address.
        """
        ...
    
    def symbolic_expressions_at(self, addrs: typing.Union[int, range]) -> typing.Iterable[SymbolicExpressionElement]:
        """Finds all the symbolic expressions that begin at an address or
        range of addresses.

        :param addrs: Either a ``range`` object or a single address.
        :returns: Yields ``(interval, offset, symexpr)`` tuples for every
            symbolic expression in the range.
        """
        ...
    


