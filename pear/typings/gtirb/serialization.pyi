"""
This type stub file was generated by pyright.
"""

from typing import Any, BinaryIO, Callable, Mapping, Optional, Sequence, Set, Tuple, Union
from uuid import UUID
from .node import Node
from .offset import Offset

CacheLookupFn = Optional[Callable[[UUID], Optional[Node]]]
class CodecError(Exception):
    """Base class for codec exceptions."""
    ...


class DecodeError(CodecError):
    """An exception during decoding."""
    ...


class EncodeError(CodecError):
    """An exception during encoding."""
    ...


class TypeNameError(EncodeError):
    """A type name is malformed."""
    def __init__(self, hint: str) -> None:
        ...
    


class UnknownCodecError(CodecError):
    """An unknown codec name is encountered.
    Caught and handled by the top-level codec methods.

    :param name: the name of the unknown codec
    """
    def __init__(self, name: str) -> None:
        ...
    


class SubtypeTree:
    """A type hint representing a parsed serialization type name.
    A ``SubtypeTree`` is has two items: A ``str`` giving
    the name of the type and a Sequence of type parameters
    (which are also ``SubtypeTree``\\s). For example, the following are all
    valid ``SubtypeTree``\\s:

    >>> SubtypeTree('string', ())
    >>> SubtypeTree('sequence', (SubtypeTree('UUID',()),))
    >>> SubtypeTree(
        'mapping', (
            SubtypeTree('string', ()),
            SubtypeTree('set', (SubtypeTree('UUID', ()),))
        )
    )
    """
    def __init__(self, name: str, subtypes: Sequence[SubtypeTree]) -> None:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    


class Variant:
    def __init__(self, index: int, val: Any) -> None:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    


class Codec:
    """The base class for codecs."""
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization, subtypes: Sequence[SubtypeTree], get_by_uuid: CacheLookupFn = ...) -> object:
        """Decode the specified raw data into a Python object.

        :param raw_bytes: The BytesIO object to be decoded.
        :param serialization: A Serialization instance used to invoke
            other codecs if needed.
        :param subtypes: The parsed type of this object.
        :param get_by_uuid: A function to look up nodes by UUID.
        :returns: A new Python object, as decoded from ``raw_bytes``.
        """
        ...
    
    @staticmethod
    def encode(out: BinaryIO, item: object, *, serialization: Serialization, subtypes: Sequence[SubtypeTree]) -> None:
        """Encode an item, writing the serialized object to ``out``.

        :param out: A binary stream to serialize to.
        :param item: The arbitrary Python object to encode.
        :param serialization: A Serialization instance, used to invoke
            other codecs if needed.
        :param subtypes: The parsed type of this object.
        """
        ...
    


class MappingCodec(Codec):
    """A Codec for mapping<K,V> entries. Implemented via ``dict``."""
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization, subtypes: Sequence[SubtypeTree], get_by_uuid: Optional[CacheLookupFn] = ...) -> Mapping[object, object]:
        ...
    
    @staticmethod
    def encode(out: BinaryIO, mapping: object, *, serialization: Serialization, subtypes: Sequence[SubtypeTree]) -> None:
        ...
    


class OffsetCodec(Codec):
    """A Codec for :class:`gtirb.Offset` objects,
    containing a UUID and a displacement.
    """
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ..., get_by_uuid: Optional[CacheLookupFn] = ...) -> Offset:
        ...
    
    @staticmethod
    def encode(out: BinaryIO, val: object, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ...) -> None:
        ...
    


class SequenceCodec(Codec):
    """A Codec for sequence<T> entries. Implemented via ``list``."""
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization, subtypes: Sequence[SubtypeTree], get_by_uuid: Optional[CacheLookupFn] = ...) -> Sequence[object]:
        ...
    
    @staticmethod
    def encode(out: BinaryIO, sequence: object, *, serialization: Serialization, subtypes: Sequence[SubtypeTree]) -> None:
        ...
    


class SetCodec(Codec):
    """A Codec for set<T> entries. Implemented via ``set``."""
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization, subtypes: Sequence[SubtypeTree], get_by_uuid: Optional[CacheLookupFn] = ...) -> Set[object]:
        ...
    
    @staticmethod
    def encode(out: BinaryIO, items: object, *, serialization: Serialization, subtypes: Sequence[SubtypeTree]) -> None:
        ...
    


class TupleCodec(Codec):
    """A Codec for tuple<...> entries. Implemented via ``tuple``."""
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization, subtypes: Sequence[SubtypeTree], get_by_uuid: Optional[CacheLookupFn] = ...) -> Tuple[object, ...]:
        ...
    
    @staticmethod
    def encode(out: BinaryIO, items: object, *, serialization: Serialization, subtypes: Sequence[SubtypeTree]) -> None:
        ...
    


class StringCodec(Codec):
    """A Codec for strings."""
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ..., get_by_uuid: Optional[CacheLookupFn] = ...) -> str:
        ...
    
    @staticmethod
    def encode(out: BinaryIO, val: object, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ...) -> None:
        ...
    


class BoolCodec(Codec):
    """A Codec for bool."""
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ..., get_by_uuid: Optional[CacheLookupFn] = ...) -> bool:
        ...
    
    @staticmethod
    def encode(out: BinaryIO, val: object, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ...) -> None:
        ...
    


class IntegerCodec(Codec):
    """Generic base class for integer-based Codecs"""
    typname: str
    bytesize: int
    signed: bool
    @classmethod
    def decode(cls, raw_bytes: BinaryIO, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ..., get_by_uuid: Optional[CacheLookupFn] = ...) -> int:
        ...
    
    @classmethod
    def encode(cls, out: BinaryIO, val: object, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ...) -> None:
        ...
    


class Uint64Codec(IntegerCodec):
    """A Codec for 64-bit unsigned integers."""
    typname = ...
    bytesize = ...
    signed = ...


class Uint32Codec(IntegerCodec):
    """A Codec for 32-bit unsigned integers."""
    typname = ...
    bytesize = ...
    signed = ...


class Uint16Codec(IntegerCodec):
    """A Codec for 16-bit unsigned integers."""
    typname = ...
    bytesize = ...
    signed = ...


class Uint8Codec(IntegerCodec):
    """A Codec for 8-bit unsigned integers."""
    typname = ...
    bytesize = ...
    signed = ...


class Int64Codec(IntegerCodec):
    """A Codec for 64-bit signed integers."""
    typname = ...
    bytesize = ...
    signed = ...


class Int32Codec(IntegerCodec):
    """A Codec for 32-bit signed integers."""
    typname = ...
    bytesize = ...
    signed = ...


class Int16Codec(IntegerCodec):
    """A Codec for 16-bit signed integers."""
    typname = ...
    bytesize = ...
    signed = ...


class Int8Codec(IntegerCodec):
    """A Codec for 8-bit signed integers."""
    typname = ...
    bytesize = ...
    signed = ...


class FloatCodec(Codec):
    """Generic base class for float-based Codecs"""
    typname: str
    bytesize: int
    struct_format: str
    @classmethod
    def decode(cls, raw_bytes: BinaryIO, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ..., get_by_uuid: Optional[CacheLookupFn] = ...) -> float:
        ...
    
    @classmethod
    def encode(cls, out: BinaryIO, val: object, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ...) -> None:
        ...
    


class Float32Codec(FloatCodec):
    typname = ...
    bytesize = ...
    struct_format = ...


class Float64Codec(FloatCodec):
    typname = ...
    bytesize = ...
    struct_format = ...


class UUIDCodec(Codec):
    """A Codec for raw UUIDs or Nodes.

    Decoding a UUID first checks the Node cache for an object with the
    corresponding UUID, and either returns the object it hits or a new
    raw UUID.
    """
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ..., get_by_uuid: Optional[CacheLookupFn] = ...) -> Union[UUID, Node]:
        ...
    
    @staticmethod
    def encode(out: BinaryIO, val: object, *, serialization: Serialization = ..., subtypes: Sequence[SubtypeTree] = ...) -> None:
        ...
    


class VariantCodec(Codec):
    """A Codec for variant<Ts...> entries.

    An encoded record containg two part:
    index - position of member of variant's list
    value - encoded values of selected member
    """
    @staticmethod
    def decode(raw_bytes: BinaryIO, *, serialization: Serialization, subtypes: Sequence[SubtypeTree] = ..., get_by_uuid: Optional[CacheLookupFn] = ...) -> Variant:
        ...
    
    @staticmethod
    def encode(out: BinaryIO, variant: object, *, serialization: Serialization, subtypes: Sequence[SubtypeTree] = ...) -> None:
        ...
    


class UnknownData(bytes):
    """This class is a blob of bytes representing data with an unknown type.
    Generated by :func:`gtirb.Serialization.decode` when it encounters
    the name of an unknown codec. Use only at the top level of an auxdata.
    """
    ...


class Serialization:
    """Manages codecs used to serialize and deserialize GTIRB objects.

    The :meth:`gtirb.Serialization.decode` method of
    :attr:`gtirb.AuxData.serializer` is called when GTIRB AuxData is loaded via
    :meth:`gtirb.IR.load_protobuf`, and the :meth:`gtirb.Serialization.encode`
    method of :attr:`gtirb.AuxData.serializer` is called when GTIRB AuxData is
    saved to file via :meth:`gtirb.IR.save_protobuf`. You can alter the
    encoding and decoding of AuxData values via
    :attr:`gtirb.Serialization.codecs`. To do this, create a new subclass of
    :class:`gtirb.serialization.Codec` and add it to
    :attr:`gtirb.Serialization.codecs`:

    >>> gtirb.AuxData.serializer.codecs['my_custom_type'] = MyCustomCodec

    This example registers a new type name, ``my_custom_type``, and associate
    it with a new codec, ``MyCustomCodec``.

    :ivar ~.codecs: A mapping of type names to codecs. Codecs can be added
        or overridden using this dictionary.
    """
    def __init__(self) -> None:
        """Initialize with the built-in `gtirb.serialization.Codec`
        subclasses.
        """
        ...
    
    def decode(self, raw_bytes: Union[bytes, bytearray, memoryview, BinaryIO], type_name: str, get_by_uuid: CacheLookupFn = ...) -> object:
        """Decode a :class:`gtirb.AuxData` of the specified type
        from the specified byte stream.

        :param raw_bytes: The byte stream from which to read the encoded value.
        :param type_name: The type name of the object encoded by ``raw_bytes``.
        :param get_by_uuid: A function to look up nodes by UUID.
        :returns: The object encoded by ``raw_bytes``.
        """
        ...
    
    def encode(self, out: BinaryIO, val: object, type_name: str) -> None:
        """Encodes the value of an AuxData value to bytes.

        :param out: A binary stream to write bytes to.
        :param val: The :class:`gtirb.AuxData` to encode.
        :param type_name: The type name of the value encapsulated
            by the :class:`gtirb.AuxData`.
        """
        ...
    


